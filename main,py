import numpy as np
import tensorflow as tf
from tensorflow.keras import layers
import pandas as pd
from typing import Dict, List, Tuple, Optional
from sklearn.preprocessing import MinMaxScaler
from scipy.interpolate import InterpolatedUnivariateSpline
import datetime
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)

class TimeSeriesPredictor:
    """Neural network for time series prediction of sensor and atmospheric data"""
    def __init__(self, sequence_length: int = 50, forecast_horizon: int = 10):
        self.sequence_length = sequence_length
        self.forecast_horizon = forecast_horizon
        self.scaler = MinMaxScaler()
        self.model = self._build_model()
        
    def _build_model(self) -> tf.keras.Model:
        """Build an LSTM-based sequence prediction model"""
        model = tf.keras.Sequential([
            layers.LSTM(64, input_shape=(self.sequence_length, 1), return_sequences=True),
            layers.Dropout(0.2),
            layers.LSTM(32, return_sequences=False),
            layers.Dropout(0.2),
            layers.Dense(self.forecast_horizon)
        ])
        
        model.compile(
            optimizer=tf.keras.optimizers.Adam(learning_rate=0.001),
            loss='mse',
            metrics=['mae']
        )
        return model

    def prepare_sequences(self, data: np.ndarray) -> Tuple[np.ndarray, np.ndarray]:
        """Prepare sequences for training"""
        X, y = [], []
        
        for i in range(len(data) - self.sequence_length - self.forecast_horizon):
            X.append(data[i:(i + self.sequence_length)])
            y.append(data[(i + self.sequence_length):(i + self.sequence_length + self.forecast_horizon)])
        
        return np.array(X), np.array(y)

    def train(self, data: np.ndarray, epochs: int = 50, batch_size: int = 32) -> Dict:
        """Train the model on historical data"""
        scaled_data = self.scaler.fit_transform(data.reshape(-1, 1))
        X, y = self.prepare_sequences(scaled_data)
        
        history = self.model.fit(
            X, y,
            epochs=epochs,
            batch_size=batch_size,
            validation_split=0.2,
            verbose=1
        )
        
        return history.history

    def predict(self, sequence: np.ndarray) -> np.ndarray:
        """Predict future values"""
        scaled_sequence = self.scaler.transform(sequence.reshape(-1, 1))
        scaled_prediction = self.model.predict(scaled_sequence.reshape(1, self.sequence_length, 1))
        return self.scaler.inverse_transform(scaled_prediction)

class EnhancedSensorData:
    """Enhanced sensor data handling with prediction capabilities"""
    def __init__(self, sequence_length: int = 50):
        self.sequence_length = sequence_length
        self.data_buffer = {
            'accelerometer': np.zeros((sequence_length, 3)),
            'gyroscope': np.zeros((sequence_length, 3)),
            'gps': np.zeros((sequence_length, 3)),
            'pressure': np.zeros(sequence_length),
            'temperature': np.zeros(sequence_length),
            'density': np.zeros(sequence_length),
            'wind_velocity': np.zeros((sequence_length, 3)),
            'humidity': np.zeros(sequence_length),
            'altitude': np.zeros(sequence_length)
        }
        
        # Create predictors for each sensor type
        self.predictors = {
            'pressure': TimeSeriesPredictor(sequence_length),
            'temperature': TimeSeriesPredictor(sequence_length),
            'density': TimeSeriesPredictor(sequence_length),
            'humidity': TimeSeriesPredictor(sequence_length),
            'altitude': TimeSeriesPredictor(sequence_length)
        }
        
        # Create predictors for vector quantities
        for i in range(3):  # For x, y, z components
            self.predictors[f'accelerometer_{i}'] = TimeSeriesPredictor(sequence_length)
            self.predictors[f'gyroscope_{i}'] = TimeSeriesPredictor(sequence_length)
            self.predictors[f'gps_{i}'] = TimeSeriesPredictor(sequence_length)
            self.predictors[f'wind_velocity_{i}'] = TimeSeriesPredictor(sequence_length)

        self.timestamp = []
        
    def update(self, new_data: Dict[str, np.ndarray]) -> None:
        """Update sensor readings and maintain historical buffer"""
        current_time = datetime.datetime.now()
        self.timestamp.append(current_time)
        
        for key, value in new_data.items():
            if key in self.data_buffer:
                if isinstance(value, (np.ndarray, list)) and len(value) == 3:
                    self.data_buffer[key] = np.roll(self.data_buffer[key], -1, axis=0)
                    self.data_buffer[key][-1] = np.array(value)
                elif isinstance(value, (int, float)):
                    self.data_buffer[key] = np.roll(self.data_buffer[key], -1)
                    self.data_buffer[key][-1] = float(value)
                else:
                    logger.warning(f"Invalid data format for sensor {key}")
            else:
                logger.warning(f"Unknown sensor type: {key}")

    def train_predictors(self, historical_data: Dict[str, np.ndarray]) -> None:
        """Train predictors using historical data"""
        for key, predictor in self.predictors.items():
            if '_' in key:  # Vector component
                base_key, index = key.split('_')
                data = historical_data[base_key][:, int(index)]
            else:
                data = historical_data[key]
            
            predictor.train(data)

    def predict_future_values(self, steps: int) -> Dict[str, np.ndarray]:
        """Predict future sensor values"""
        predictions = {}
        
        # Predict scalar quantities
        for key in ['pressure', 'temperature', 'density', 'humidity', 'altitude']:
            sequence = self.data_buffer[key]
            predictions[key] = self.predictors[key].predict(sequence)[-steps:]
        
        # Predict vector quantities
        vector_quantities = ['accelerometer', 'gyroscope', 'gps', 'wind_velocity']
        for qty in vector_quantities:
            predictions[qty] = np.zeros((steps, 3))
            for i in range(3):
                sequence = self.data_buffer[qty][:, i]
                predictions[qty][:, i] = self.predictors[f'{qty}_{i}'].predict(sequence)[-steps:]
        
        return predictions

class EnhancedAtmosphericModel:
    """Enhanced atmospheric modeling with prediction capabilities"""
    def __init__(self):
        self.g0 = 9.81  # Standard gravity at sea level
        self.R = 287.05  # Gas constant for air
        self.p0 = 101325  # Standard pressure at sea level
        self.T0 = 288.15  # Standard temperature at sea level
        self.rho0 = 1.225  # Standard density at sea level
        self.L = 0.0065  # Temperature lapse rate
        
        # Historical data storage
        self.history = {
            'altitude': [],
            'pressure': [],
            'temperature': [],
            'density': [],
            'wind_speed': [],
            'wind_direction': [],
            'humidity': []
        }
        
    def update_history(self, data: Dict[str, float]) -> None:
        """Update historical atmospheric data"""
        for key, value in data.items():
            if key in self.history:
                self.history[key].append(value)

    def calculate_pressure(self, altitude: float, base_pressure: float = None) -> float:
        """Calculate pressure at given altitude using hypsometric equation"""
        if base_pressure is None:
            base_pressure = self.p0
        
        return base_pressure * np.exp(-self.g0 * altitude / (self.R * self.T0))

    def calculate_temperature(self, altitude: float, surface_temp: float = None) -> float:
        """Calculate temperature at given altitude using lapse rate"""
        if surface_temp is None:
            surface_temp = self.T0
            
        return surface_temp - self.L * altitude

    def calculate_density(self, pressure: float, temperature: float) -> float:
        """Calculate air density using ideal gas law"""
        return pressure / (self.R * temperature)

    def calculate_wind_effect(self, wind_velocity: np.ndarray, rocket_velocity: np.ndarray) -> np.ndarray:
        """Calculate wind effect considering altitude-dependent factors"""
        altitude = np.linalg.norm(rocket_velocity) * np.sin(np.arctan2(rocket_velocity[2], 
                                                                      np.sqrt(rocket_velocity[0]**2 + rocket_velocity[1]**2)))
        
        # Wind speed typically increases with altitude
        altitude_factor = np.clip(1 + altitude/1000, 1, 2)
        relative_velocity = wind_velocity * altitude_factor - rocket_velocity
        
        # Calculate Reynolds number (simplified)
        characteristic_length = 1.0  # rocket diameter in meters
        kinematic_viscosity = 1.46e-5  # air at 20°C
        reynolds_number = np.linalg.norm(relative_velocity) * characteristic_length / kinematic_viscosity
        
        # Drag coefficient (simplified)
        if reynolds_number < 1e5:
            cd = 0.5
        else:
            cd = 0.2
        
        return 0.5 * self.rho0 * cd * np.linalg.norm(relative_velocity) * relative_velocity

    def predict_conditions(self, altitude: float, time_ahead: float = 0.0) -> Dict[str, float]:
        """Predict atmospheric conditions at a given altitude and time"""
        # Basic predictions based on standard atmospheric models
        predicted_temp = self.calculate_temperature(altitude)
        predicted_pressure = self.calculate_pressure(altitude)
        predicted_density = self.calculate_density(predicted_pressure, predicted_temp)
        
        # Add time-based variations (simplified model)
        time_factor = np.sin(2 * np.pi * time_ahead / 86400)  # Daily variation
        temp_variation = 5.0 * time_factor  # ±5°C daily variation
        pressure_variation = 100 * time_factor  # ±100 Pa daily variation
        
        return {
            'temperature': predicted_temp + temp_variation,
            'pressure': predicted_pressure + pressure_variation,
            'density': predicted_density,
            'wind_speed': 10 + 5 * time_factor,  # Simple wind speed model
            'wind_direction': 180 + 45 * time_factor  # Simple wind direction model
        }

class AtmosphericDataAnalyzer:
    """Analyze and predict atmospheric patterns"""
    def __init__(self, data_window: int = 1000):
        self.data_window = data_window
        self.atmospheric_data = pd.DataFrame(columns=[
            'timestamp', 'altitude', 'pressure', 'temperature', 
            'density', 'wind_speed', 'wind_direction', 'humidity'
        ])
        
    def add_data_point(self, data: Dict[str, float]) -> None:
        """Add new atmospheric data point"""
        data['timestamp'] = datetime.datetime.now()
        self.atmospheric_data = pd.concat([
            self.atmospheric_data,
            pd.DataFrame([data])
        ]).tail(self.data_window)

    def analyze_patterns(self) -> Dict[str, Dict[str, float]]:
        """Analyze atmospheric patterns in the data"""
        results = {}
        
        for column in self.atmospheric_data.columns:
            if column != 'timestamp':
                data = self.atmospheric_data[column].values
                results[column] = {
                    'mean': np.mean(data),
                    'std': np.std(data),
                    'trend': np.polyfit(range(len(data)), data, 1)[0]
                }
                
        return results

    def predict_future_conditions(self, future_time: datetime.datetime) -> Dict[str, float]:
        """Predict future atmospheric conditions"""
        predictions = {}
        current_time = self.atmospheric_data['timestamp'].max()
        time_diff = (future_time - current_time).total_seconds()
        
        for column in self.atmospheric_data.columns:
            if column != 'timestamp':
                # Create spline interpolation of historical data
                y = self.atmospheric_data[column].values
                x = np.arange(len(y))
                spline = InterpolatedUnivariateSpline(x, y)
                
                # Extrapolate to future time
                future_x = len(y) + time_diff / 60  # Convert to minutes
                predictions[column] = float(spline(future_x))
                
        return predictions

def main():
    # Initialize systems
    sensor_system = EnhancedSensorData()
    atmospheric_model = EnhancedAtmosphericModel()
    data_analyzer = AtmosphericDataAnalyzer()
    
    # Simulate data collection and prediction
    for t in range(100):
        # Simulate sensor readings
        sensor_data = {
            'accelerometer': np.random.normal(0, 1, 3),
            'gyroscope': np.random.normal(0, 0.1, 3),
            'gps': np.array([0, 0, t * 10]),
            'pressure': 101325 * np.exp(-t * 10 / 7400),
            'temperature': 288.15 - 0.0065 * t * 10,
            'density': 1.225 * np.exp(-t * 10 / 7400),
            'wind_velocity': np.random.normal(0, 5, 3),
            'humidity': 50 + np.random.normal(0, 5),
            'altitude': t * 10
        }
        
        # Update systems
        sensor_system.update(sensor_data)
        atmospheric_model.update_history(sensor_data)
        data_analyzer.add_data_point(sensor_data)
        
        # Make predictions
        if t > 50:  # Wait for enough data
            future_predictions = sensor_system.predict_future_values(steps=10)
            atmospheric_patterns = data_analyzer.analyze_patterns()
            future_time = datetime.datetime.now() + datetime.timedelta(minutes=10)
            future_conditions = data_analyzer.predict_future_conditions(future_time)
            
            logger.info(f"Time step {t}")
            logger.info(f"Predicted altitude in 10 steps: {future_predictions['altitude'][-1]}")
            logger.info(f"Atmospheric patterns: {atmospheric_patterns['pressure']['trend']}")
            logger.info(f"Future conditions: {future_conditions['pressure']}")

if __name__ == "__main__":
    main()
